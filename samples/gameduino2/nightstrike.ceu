input void GD_REDRAW;
input (int,int,int) GD_TOUCH;

native do
    #include "nightstrike_welcome_assets.h"
    #include "nightstrike_1_assets.h"
    
    Streamer stream;
    
    static PROGMEM prog_uchar soldier_a[] = {0,0,0,1,1,2,2,3,3,4,4,4,5,5,6,6,7,7};
    static PROGMEM prog_uchar fire_a[] = {0,1,2,3,4,5,6,7,8, 9,9, 10,10, 11,11, 12,12, 13,13, 14,14, 15,15, 16,16};
    
    #define SOLDIER_LEFT   (-SOLDIER_RUN_WIDTH / 2)
    #define SOLDIER_RIGHT  (480 + (SOLDIER_RUN_WIDTH / 2))
    
    #define HELI_LEFT (-HELI_WIDTH / 2)
    #define HELI_RIGHT (480 + HELI_WIDTH / 2)
    
    #define HOMING_SPEED  32
    #define HOMING_SLEW  400
    static void blocktext(int x, int y, byte font, const char *s)
    {
      GD.SaveContext();
      GD.ColorRGB(0x000000);
      GD.cmd_text(x-1, y-1, font, 0, s);
      GD.cmd_text(x+1, y-1, font, 0, s);
      GD.cmd_text(x-1, y+1, font, 0, s);
      GD.cmd_text(x+1, y+1, font, 0, s);
      GD.RestoreContext();

      GD.cmd_text(x, y, font, 0, s);
    }
    
    void draw_dxt1(byte color_handle, byte bit_handle)
    {
      GD.Begin(BITMAPS);

      GD.BlendFunc(ONE, ZERO);
      GD.ColorA(0x55);
      GD.Vertex2ii(0, 0, bit_handle, 0);

      GD.BlendFunc(ONE, ONE);
      GD.ColorA(0xaa);
      GD.Vertex2ii(0, 0, bit_handle, 1);

      GD.ColorMask(1,1,1,0);
      GD.cmd_scale(F16(4), F16(4));
      GD.cmd_setmatrix();

      GD.BlendFunc(DST_ALPHA, ZERO);
      GD.Vertex2ii(0, 0, color_handle, 1);

      GD.BlendFunc(ONE_MINUS_DST_ALPHA, ONE);
      GD.Vertex2ii(0, 0, color_handle, 0);

      GD.RestoreContext();
    }
    
    void vertex(byte cell, byte scale, const shape_t *shape, int x, int y) {
        int x0, y0;
        x0 = x - (shape->w >> 1) * scale;
        y0 = y - (shape->h >> 1) * scale;
        if (((x0 | y0) & 511) == 0) {
          GD.Vertex2ii(x0, y0, shape->handle, cell);
        } else {
          GD.BitmapHandle(shape->handle);
          GD.Cell(cell);
          GD.Vertex2f(x0 << 4, y0 << 4);
        }
      }
      
      void load_level(int n){

        GD.Clear();
        GD.cmd_text(240, 110, 29, OPT_CENTER, "LEVEL");
        GD.cmd_number(240, 145, 31, OPT_CENTER, n + 1);
        GD.swap();
        GD.finish();

        char filename[] = "night#.gd2";
        filename[5] = '0' + (n % 5);
        GD.load(filename);
      }
    
    void drawtemp(const shape_t *shape){
          GD.cmd_translate(F16(shape->w / 2), F16(shape->h / 2));
          GD.cmd_scale(F16(-1), F16(1));
          GD.cmd_translate(F16(-(shape->w / 2)), F16(-(shape->h / 2)));
          GD.cmd_setmatrix();
    }
    
    void drawmissile(const shape_t *shape, uint16_t angle, int x, int y){
        GD.cmd_loadidentity();
        GD.cmd_translate(F16(shape->size / 2), F16(shape->size / 2));
        GD.cmd_rotate(angle);
        GD.cmd_translate(F16(-(shape->w / 2)), F16(-(shape->h / 2)));
        GD.cmd_setmatrix();
        
        int x0, y0;
        x0 = x - (shape->size << 3);
        y0 = y - (shape->size << 3);
        GD.BitmapHandle(shape->handle);
        GD.Cell(0);
        GD.Vertex2f(x0, y0);
    }
end

_GD.load("nightw.gd2");


/// THE OPENING SEQUENCE

var int on? = true;
par/or do
    every 500ms do
        on? = not on?;
    end
with
    every GD_REDRAW do
        _draw_dxt1(BACKGROUND_COLOR_HANDLE, BACKGROUND_BITS_HANDLE);
        _GD.ColorRGB(0xd7f2fd);
        _blocktext(25, 16, WELCOME_DISPLAYFONT_HANDLE, "NIGHTSTRIKE");
        _GD.Tag(100);
        if(on?) then
            _blocktext(51, 114, WELCOME_DISPLAYFONT_HANDLE, "START");
        end
    end
with
    var int x,y,tag;
    (x,y,tag) = await GD_TOUCH
                    until tag == 100;
end

/// END OF OPENING SEQUENCE

class Fires with
    var int x, y;
do
    var int t = 0;
    
    x = x >> 4;
    y = y >> 4;
    native do
        const shape_t *shape3;
    end
    _shape3 = &_FIRE_SHAPE;
    var int anim = 0;
    every GD_REDRAW do
        if( anim == 24) then
            break;
        end
        _vertex( _pgm_read_byte(_fire_a + anim), 1, _shape3, x, y );
        if( t % 2 == 0 ) then
            anim = anim + 1;
        end
        t = t + 1;
    end
end

class Missile with
    var int x,y;
do
    var int dir;
    var s8 th, ts;
    var s16 vx,vy;
    native do
         const shape_t *shape2;
    end
    var u16 angle = 0x4000,a;
    vx = -_GD.rsin(10, angle);
    vy =  _GD.rcos(10, angle);
    th = 0;
    ts = -1;
    _shape2 = &_MISSILE_C_SHAPE;
    var int t = 0;
    if (angle == 0xc000) then
        dir = 1;
    else
        dir = -1;
    end
    pool Fires[6] f;
    
    every GD_REDRAW do
        _GD.Begin(_BITMAPS);
        vx = -_GD.rsin(_HOMING_SPEED, angle);
        vy = _GD.rcos(_HOMING_SPEED, angle);
        var s16 dy = (16 * 272) - y;
        var s16 dx = (16 * 240) - x;
        var u16 seek = _GD.atan2(dy, dx);
        var s16 steer = seek - angle;
        if (_abs(steer) > _HOMING_SLEW) then
            angle = angle - (dir * _HOMING_SLEW);
        else
            dir = 0;
        end
        
        x = x + vx;
        y = y + vy;
        _GD.SaveContext();
        _drawmissile(_shape2, angle, x, y);
        _GD.RestoreContext();
        
        if( (t & 7) == 0) then
            a = 0x8000 + angle; 
            spawn Fires in f with
                this.x = x - _GD.rsin(22 * 16, a);
                this.y = y + _GD.rcos(22 * 16, a);
            end;
        end
  
        t = t  + 1;
    end
end

class Soldier with
do
    var int x,y;
    native do
         const shape_t *shape;
    end
    _shape = &_SOLDIER_RUN_SHAPE;
    y = 272 - _SOLDIER_RUN_HEIGHT / 2;
    var int t = 0;
    var byte a = 0;
    /*
    x = _SOLDIER_RIGHT;
    every GD_REDRAW do            
        _GD.Begin(_BITMAPS);
            
        x = x - 1;
        t = t + 1;
        if (t % 2 == 0) then
            a = (a + 1) % _sizeof(_soldier_a);
        end
    end
    */
    x = _SOLDIER_LEFT;   
    every GD_REDRAW do
                        
        _GD.Begin(_BITMAPS);
        _GD.SaveContext();
        _GD.cmd_loadidentity();
            
        _drawtemp(_shape);
            
        _vertex(_pgm_read_byte(_soldier_a + a), 1, _shape, x,y);
        _GD.RestoreContext();
        x = x + 1;
        t = t + 1;
        if (t % 2 == 0) then
            a = (a + 1) % _sizeof(_soldier_a);
        end
    end
end

class Heli with
do
    var int x,y;
    native do
         const shape_t *shape1;
    end
    _shape1 = &_HELI_SHAPE;
    y = (_HELI_HEIGHT / 2 ) + _GD.random(100);
    var int t = 0;
    
    pool Missile[1] m;
    
    x = _HELI_RIGHT;
    every GD_REDRAW do
        _GD.Begin(_BITMAPS);
        _vertex( (t>>2 & 1),1,_shape1,x,y);
        t = t  + 1;
        if(t == 200) then
            spawn Missile in m with
                this.x = x << 4;
                this.y = y << 4;
            end;
        end
        x = x - 1;
    end
    
    /*
    x = _HELI_LEFT;
    every GD_REDRAW do
        _GD.Begin(_BITMAPS);
        _GD.SaveContext();
        _GD.cmd_loadidentity();
            
        _drawtemp(_shape1);
        _vertex( (t>>2 & 1),1,_shape1,x,y);
        _GD.RestoreContext();
        
        t = t + 1;
        x = x + 1;
    end
    */
end



class MissileBase with
do
    var int x,y;
    var u16 vel = 60;
    var s8 th, ts;
    var s16 vx,vy;
    native do
         const shape_t *shape4;
    end
    var u16 angle = 0x6000,a;
    x = 16 * 240 - _GD.rsin( 16 * 110, angle);
    y = 16 * 265 + _GD.rcos( 16 * 110, angle);

    vx = -_GD.rsin(vel, angle);
    vy =  _GD.rcos(vel, angle);
    th = 0;
    ts = 0;
    _shape4 = &_MISSILE_A_SHAPE;
    var int t = 0;
    
    every GD_REDRAW do
        _GD.ColorA(255);
        _GD.Begin(_BITMAPS);
        angle = _GD.atan2(vy, vx);
        vy = vy + 4;

        x = x + vx;
        y = y + vy;
        _GD.SaveContext();
        _drawmissile(_shape4, angle, x, y);
        _GD.RestoreContext();

        t = t  + 1;
    end
end

_GD.cmd_track(240, 271, 1, 1, 0x01);
_load_level(0);

par/or do
    every GD_REDRAW do
        _GD.Tag(1);
        _draw_dxt1(BACKGROUND_COLOR_HANDLE, BACKGROUND_BITS_HANDLE);
        _GD.TagMask(0);
        _GD.Begin(_BITMAPS);
    end
with
    var Soldier s;
    var Heli h;
    //var Missile m;
    var MissileBase m1;
    //var Fires f;
    await FOREVER;
with
    await 10s;
end

await FOREVER;