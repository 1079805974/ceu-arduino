#include "c.ceu"
#include "arduino/avr.ceu"
#include "arduino/arduino.ceu"

native
   _CONFIG      ,
   _EN_AA       ,
   _EN_RXADDR   ,
   _SETUP_AW    ,
   _SETUP_RETR  ,
   _RF_CH       ,
   _RF_SETUP    ,
   _STATUS      ,
   _OBSERVE_TX  ,
   _CD          ,
   _RX_ADDR_P0  ,
   _RX_ADDR_P1  ,
   _RX_ADDR_P2  ,
   _RX_ADDR_P3  ,
   _RX_ADDR_P4  ,
   _RX_ADDR_P5  ,
   _TX_ADDR     ,
   _RX_PW_P0    ,
   _RX_PW_P1    ,
   _RX_PW_P2    ,
   _RX_PW_P3    ,
   _RX_PW_P4    ,
   _RX_PW_P5    ,
   _FIFO_STATUS ,
   _DYNPD	,
   _FEATURE	,
    
    /* Bit Mnemonics */
    _MASK_RX_DR  ,
    _MASK_TX_DS  ,
    _MASK_MAX_RT ,
    _EN_CRC      ,
    _CRCO        ,
    _PWR_UP      ,
    _PRIM_RX     ,
    _ENAA_P5     ,
    _ENAA_P4     ,
    _ENAA_P3     ,
    _ENAA_P2     ,
    _ENAA_P1     ,
    _ENAA_P0     ,
    _ERX_P5      ,
    _ERX_P4      ,
    _ERX_P3      ,
    _ERX_P2      ,
    _ERX_P1      ,
    _ERX_P0      ,
    _AW          ,
    _ARD         ,
    _ARC         ,
    _PLL_LOCK    ,
    _RF_DR       ,
    _RF_PWR      ,
    _RX_DR       ,
    _TX_DS       ,
    _MAX_RT      ,
    _RX_P_NO     ,
    _TX_FULL     ,
    _PLOS_CNT    ,
    _ARC_CNT     ,
    _TX_REUSE    ,
    _FIFO_FULL   ,
    _TX_EMPTY    ,
    _RX_FULL     ,
    _RX_EMPTY    ,
    _DPL_P5	 ,
    _DPL_P4	 ,
    _DPL_P3	 ,
    _DPL_P2	 ,
    _DPL_P1	 ,
    _DPL_P0	 ,
    _EN_DPL	 ,
    _EN_ACK_PAY  ,
    _EN_DYN_ACK  ,
    
    /* Instruction Mnemonics */
    _R_REGISTER    ,
    _W_REGISTER    ,
    _REGISTER_MASK ,
    _ACTIVATE      ,
    _R_RX_PL_WID   ,
    _R_RX_PAYLOAD  ,
    _W_TX_PAYLOAD  ,
    _W_ACK_PAYLOAD ,
    _FLUSH_TX      ,
    _FLUSH_RX      ,
    _REUSE_TX_PL   ,
    _NOP           ,
    
    /* Non-P omissions */
    _LNA_HCURR   ,
    
    /* P model memory Map */
    _RPD        , 
    
    /* P model bit Mnemonics */
    _RF_DR_LOW ,
    _RF_DR_HIGH,
    _RF_PWR_LOW
;
native/pre do
 
    ##define CONFIG      0x00
    ##define EN_AA       0x01
    ##define EN_RXADDR   0x02
    ##define SETUP_AW    0x03
    ##define SETUP_RETR  0x04
    ##define RF_CH       0x05
    ##define RF_SETUP    0x06
    ##define STATUS      0x07
    ##define OBSERVE_TX  0x08
    ##define CD          0x09
    ##define RX_ADDR_P0  0x0A
    ##define RX_ADDR_P1  0x0B
    ##define RX_ADDR_P2  0x0C
    ##define RX_ADDR_P3  0x0D
    ##define RX_ADDR_P4  0x0E
    ##define RX_ADDR_P5  0x0F
    ##define TX_ADDR     0x10
    ##define RX_PW_P0    0x11
    ##define RX_PW_P1    0x12
    ##define RX_PW_P2    0x13
    ##define RX_PW_P3    0x14
    ##define RX_PW_P4    0x15
    ##define RX_PW_P5    0x16
    ##define FIFO_STATUS 0x17
    ##define DYNPD	    0x1C
    ##define FEATURE	    0x1D
    
    /* Bit Mnemonics */
    ##define MASK_RX_DR  6
    ##define MASK_TX_DS  5
    ##define MASK_MAX_RT 4
    ##define EN_CRC      3
    ##define CRCO        2
    ##define PWR_UP      1
    ##define PRIM_RX     0
    ##define ENAA_P5     5
    ##define ENAA_P4     4
    ##define ENAA_P3     3
    ##define ENAA_P2     2
    ##define ENAA_P1     1
    ##define ENAA_P0     0
    ##define ERX_P5      5
    ##define ERX_P4      4
    ##define ERX_P3      3
    ##define ERX_P2      2
    ##define ERX_P1      1
    ##define ERX_P0      0
    ##define AW          0
    ##define ARD         4
    ##define ARC         0
    ##define PLL_LOCK    4
    ##define RF_DR       3
    ##define RF_PWR      6
    ##define RX_DR       6
    ##define TX_DS       5
    ##define MAX_RT      4
    ##define RX_P_NO     1
    ##define TX_FULL     0
    ##define PLOS_CNT    4
    ##define ARC_CNT     0
    ##define TX_REUSE    6
    ##define FIFO_FULL   5
    ##define TX_EMPTY    4
    ##define RX_FULL     1
    ##define RX_EMPTY    0
    ##define DPL_P5	    5
    ##define DPL_P4	    4
    ##define DPL_P3	    3
    ##define DPL_P2	    2
    ##define DPL_P1	    1
    ##define DPL_P0	    0
    ##define EN_DPL	    2
    ##define EN_ACK_PAY  1
    ##define EN_DYN_ACK  0
    
    /* Instruction Mnemonics */
    ##define R_REGISTER    0x00
    ##define W_REGISTER    0x20
    ##define REGISTER_MASK 0x1F
    ##define ACTIVATE      0x50
    ##define R_RX_PL_WID   0x60
    ##define R_RX_PAYLOAD  0x61
    ##define W_TX_PAYLOAD  0xA0
    ##define W_ACK_PAYLOAD 0xA8
    ##define FLUSH_TX      0xE1
    ##define FLUSH_RX      0xE2
    ##define REUSE_TX_PL   0xE3
    ##define NOP           0xFF
    
    /* Non-P omissions */
    ##define LNA_HCURR   0
    
    /* P model memory Map */
    ##define RPD         0x09
    
    /* P model bit Mnemonics */
    ##define RF_DR_LOW   5
    ##define RF_DR_HIGH  3
    ##define RF_PWR_LOW  1
end

native/pos do
    tceu_callback_ret ceu_callback_spi (int cmd, tceu_callback_arg p1,
                                                 tceu_callback_arg p2,
                                                 const char* file, u32 line)
    {
        tceu_callback_ret ret = { .is_handled=0 };
        switch (cmd) {
            case CEU_CALLBACK_OUTPUT:
                switch (p1.num) {
                    case CEU_OUTPUT_SPI_BEGIN: {
                        ret.is_handled = 1;

                        if(!SPI_userCount){
                            uint8_t port = digitalPinToPort(SS);
                            uint8_t bit = digitalPinToBitMask(SS);
                            volatile uint8_t *reg = portModeRegister(port);
                            
                            if(!(*reg & bit)){
                                digitalWrite(SS, HIGH);
                            }
                            
                            pinMode(SS, 1);
                            
                            SPCR |= _BV(MSTR);
                            SPCR |= _BV(SPE);

                            pinMode(SCK, 1);
                            pinMode(MOSI, 1);
                        }
                        SPI_userCount++;                        
                        break;
                    }
                    case CEU_OUTPUT_SPI_END: {
                        ret.is_handled = 1;

                        SPI_userCount--;
                        if(SPI_userCount == 0){
                            // disable SPI Module
                            SPCR &= ~_BV(SPE);
                        }

                        break;
                    }
                    case CEU_OUTPUT_SPI_TRANSACTION_BEGIN: {
                        ret.is_handled = 1;
                        tceu_output_SPI_TRANSACTION_BEGIN* pt = (tceu_output_SPI_TRANSACTION_BEGIN*) p2.ptr;

                        u32 clock    = pt->_1; 
                        u8 bitOrder = pt->_2; 
                        u8 dataMode = pt->_3;

                        ceu_dbg_assert(SPI_busyFlag == false);
                        SPI_busyFlag = true;

                        SPI_interruptSave = SREG;

                        uint8_t clockDiv;

                        if (__builtin_constant_p(clock)) {
                            if (clock >= F_CPU / 2) {
                                clockDiv = 0;
                            } else if (clock >= F_CPU / 4) {
                                clockDiv = 1;
                            } else if (clock >= F_CPU / 8) {
                                clockDiv = 2;
                            } else if (clock >= F_CPU / 16) {
                                clockDiv = 3;
                            } else if (clock >= F_CPU / 32) {
                                clockDiv = 4;
                            } else if (clock >= F_CPU / 64) {
                                clockDiv = 5;
                            } else {
                                clockDiv = 6;
                            }
                        } else {
                          uint32_t clockSetting = F_CPU / 2;
                          clockDiv = 0;
                          while (clockDiv < 6 && clock < clockSetting) {
                            clockSetting /= 2;
                            clockDiv++;
                          }
                        }

                        // Compensate for the duplicate fosc/64
                        if (clockDiv == 6)
                        clockDiv = 7;

                        // Invert the SPI2X bit
                        clockDiv ^= 0x1;

                        SPCR = _BV(SPE) | _BV(MSTR) | ((bitOrder == LSBFIRST) ? _BV(DORD) : 0) |
                          (dataMode & SPI_MODE_MASK) | ((clockDiv >> 1) & SPI_CLOCK_MASK);
                        SPSR = clockDiv & SPI_2XCLOCK_MASK;
                        
                        SPI_busyFlag = false;
                        
                        break;
                    }
                    case CEU_OUTPUT_SPI_TRANSFER_REQUEST: {
                        ret.is_handled = 1;

                        tceu_output_SPI_TRANSFER_REQUEST* pt = (tceu_output_SPI_TRANSFER_REQUEST*) p2.ptr;

                        SPCR |= _BV(SPIE);
                        if(pt->_1.is_set){
                            SPDR = (u8)(pt->_1).value;
                        } else {
                            SPDR = SPDR; // Have to write something to start conversion
                        }
                       
                        break;
                    }
                    case CEU_OUTPUT_SPI_TRANSACTION_END: {
                        ret.is_handled = 1;

                        SPI_busyFlag = false;
                        SREG = SPI_interruptSave;
                       
                        break;
                    }
                }
                break;
        }
        return ret;
    }
    tceu_callback CEU_CALLBACK_SPI = { &ceu_callback_spi, NULL };
end
{ ceu_callback_register(&CEU_CALLBACK_SPI); }

output none SPI_BEGIN;
output none SPI_END;

output (u32,u8,u8) SPI_TRANSACTION_BEGIN;
output none SPI_TRANSACTION_END;

output u8? SPI_TRANSFER_REQUEST;

event none spi_transaction_end;

var bool spi_transaction_busy;

input u8 SPI_TRANSFER_DONE;

code/await SPI_Transfer (var u8? value) -> u8 do
    if value? == true then
        emit SPI_TRANSFER_REQUEST(value!);
    else
        emit SPI_TRANSFER_REQUEST(_);
    end
    var u8 recv = await SPI_TRANSFER_DONE;
    escape recv;
end

code/await SPI_Transaction (var u32 freq, var u8 byte_order, var u8 mode) -> none do
    if outer.spi_transaction_busy then
        await outer.spi_transaction_end until outer.spi_transaction_busy == false;
    end
    outer.spi_transaction_busy = true;
    emit SPI_TRANSACTION_BEGIN(freq,byte_order,mode);
    do finalize with
        emit SPI_TRANSACTION_END;
	outer.spi_transaction_busy = false;
        emit outer.spi_transaction_end;
    end
    await FOREVER;
end

code/await SPI_Begin (none) -> none  do
    emit SPI_BEGIN;
    do finalize with
        emit SPI_END;
    end
    await FOREVER;
end

spawn async/isr [_SPI_STC_vect_num,0] do
    {
        bitClear(SPCR,SPIE);
    }
    emit SPI_TRANSFER_DONE({SPDR});
end
