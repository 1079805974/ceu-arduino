#include "c.ceu"
#include "arduino/avr.ceu"
#include "arduino/arduino.ceu"

native/pre do
  #define LSBFIRST 0
  #define MSBFIRST 1

  #define SPI_CLOCK_DIV4 0x00
  #define SPI_CLOCK_DIV16 0x01
  #define SPI_CLOCK_DIV64 0x02
  #define SPI_CLOCK_DIV128 0x03
  #define SPI_CLOCK_DIV2 0x04
  #define SPI_CLOCK_DIV8 0x05
  #define SPI_CLOCK_DIV32 0x06

  #define SPI_MODE0 0x00
  #define SPI_MODE1 0x04
  #define SPI_MODE2 0x08
  #define SPI_MODE3 0x0C

  #define SPI_MODE_MASK 0x0C  // CPOL = bit 3, CPHA = bit 2 on SPCR
  #define SPI_CLOCK_MASK 0x03  // SPR1 = bit 1, SPR0 = bit 0 on SPCR
  #define SPI_2XCLOCK_MASK 0x01  // SPI2X = bit 0 on SPSR

  volatile bool SPI_busyFlag = false;
  volatile uint8_t SPI_interruptSave = 0x0;
  volatile uint8_t SPI_userCount = 0;
end
native/pos do
    tceu_callback_ret ceu_callback_spi (int cmd, tceu_callback_arg p1,
                                                 tceu_callback_arg p2,
                                                 const char* file, u32 line)
    {
        tceu_callback_ret ret = { .is_handled=0 };
        switch (cmd) {
            case CEU_CALLBACK_OUTPUT:
                switch (p1.num) {
                    case CEU_OUTPUT_SPI_BEGIN: {
                        ret.is_handled = 1;

                        if(!usersCount){
                          uint8_t port = digitalPinToPort(SS);
                          uint8_t bit = digitalPinToBitMask(SS);
                          volatile uint8_t *reg = portModeRegister(port);
                          
                          if(!(*reg & bit)){
                              digitalWrite(SS, HIGH);
                          }
                          
                          pinMode(SS, OUTPUT);
                          
                          SPCR |= _BV(MSTR);
                          SPCR |= _BV(SPE);

                          pinMode(SCK, OUTPUT);
                          pinMode(MOSI, OUTPUT);
                        }
                        usersCount++;                        
                        break;
                    }
                    case CEU_OUTPUT_SPI_END: {
                        ret.is_handled = 1;

                        SPI_userCount--;
                        if(SPI_userCount == 0){
                          // disable SPI Module
                          SPCR &= ~_BV(SPE);
                        }

                        break;
                    }
                    case CEU_OUTPUT_SPI_BEGIN_TRANSACTION: {
                        ret.is_handled = 1;
                        // Struct here maybe?
                        tceu_output_SPI_BEGIN_TRANSACTION* pt = (tceu_output_SPI_BEGIN_TRANSACTION*) p2.ptr;

                        u8 clock    = pt->_1; 
                        u8 bitOrder = pt->_2; 
                        u8 dataMode = pt->_3;

                        ceu_dbg_assert(SPI_busyFlag == false);
                        SPI_busyFlag = true;

                        SPI_interruptSave = SREG;

                        uint8_t clockDiv;

                        if (__builtin_constant_p(clock)) {
                          if (clock >= F_CPU / 2) {
                            clockDiv = 0;
                          } else if (clock >= F_CPU / 4) {
                            clockDiv = 1;
                          } else if (clock >= F_CPU / 8) {
                            clockDiv = 2;
                          } else if (clock >= F_CPU / 16) {
                            clockDiv = 3;
                          } else if (clock >= F_CPU / 32) {
                            clockDiv = 4;
                          } else if (clock >= F_CPU / 64) {
                            clockDiv = 5;
                          } else {
                            clockDiv = 6;
                          }
                        } else {
                          uint32_t clockSetting = F_CPU / 2;
                          clockDiv = 0;
                          while (clockDiv < 6 && clock < clockSetting) {
                            clockSetting /= 2;
                            clockDiv++;
                          }
                        }

                        // Compensate for the duplicate fosc/64
                        if (clockDiv == 6)
                        clockDiv = 7;

                        // Invert the SPI2X bit
                        clockDiv ^= 0x1;

                        SPCR = _BV(SPE) | _BV(MSTR) | ((bitOrder == LSBFIRST) ? _BV(DORD) : 0) |
                          (dataMode & SPI_MODE_MASK) | ((clockDiv >> 1) & SPI_CLOCK_MASK);
                        SPSR = clockDiv & SPI_2XCLOCK_MASK;
                        
                        SPI_busyFlag = false;
                        
                        break;
                    }
                    case CEU_OUTPUT_SPI_END_TRANSACTION: {
                        ret.is_handled = 1;

                        SPI_busyFlag = false;
                        SREG = SPI_interruptSave;
                       
                        break;
                    }
                }
                break;
        }
        return ret;
    }
    tceu_callback CEU_CALLBACK_SPI = { &ceu_callback_spi, NULL };
end
{ ceu_callback_register(&CEU_CALLBACK_SPI); }
