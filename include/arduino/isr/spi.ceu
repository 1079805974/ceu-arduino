#include "c.ceu"
#include "arduino/avr.ceu"
#include "arduino/arduino.ceu"

// Constants copied from "<arduino>/hardware/avr/libraries/SPI/src/SPI.h"

#define SPI_LSBFIRST 0
#define SPI_MSBFIRST 1

#define SPI_MODE0 0x00
#define SPI_MODE1 0x04
#define SPI_MODE2 0x08
#define SPI_MODE3 0x0C

#define SPI_MODE_MASK    0x0C  // CPOL = bit 3, CPHA = bit 2 on SPCR
#define SPI_CLOCK_MASK   0x03  // SPR1 = bit 1, SPR0 = bit 0 on SPCR
#define SPI_2XCLOCK_MASK 0x01  // SPI2X = bit 0 on SPSR

native/pos do
    int ceu_callback_spi (int cmd, tceu_callback_val p1, tceu_callback_val p2)
    {
        if (cmd == CEU_CALLBACK_ABORT) {
            SPCR &= ~_BV(SPE);  // releases PIN13
        }
        return 0;               // lets the Ceu runtime abort
    }
    tceu_callback CEU_CALLBACK_SPI = { &ceu_callback_spi, NULL };
end
{ ceu_callback_register(&CEU_CALLBACK_SPI); }

var u8   spi_ref_count = 0;
var bool spi_is_busy   = false;
var u8   spi_sreg      = _;       // TODO: why is this needed?

output none SPI_BEGIN do
    outer.spi_ref_count = outer.spi_ref_count + 1;
    if outer.spi_ref_count > 1 then
        escape;
    end

    var u8   port = {digitalPinToPort(SS)};
    var u8   bit  = {digitalPinToBitMask(SS)};
    var u8&& reg  = {portModeRegister(@port)};

    if (*reg & bit) == 0 then
        {digitalWrite(SS, HIGH);}
    end

    {
        pinMode(SS, 1);

        SPCR |= _BV(MSTR);
        SPCR |= _BV(SPE);

        pinMode(SCK, 1);
        pinMode(MOSI, 1);
    }
end

output none SPI_END do
    outer.spi_ref_count = outer.spi_ref_count - 1;
    if outer.spi_ref_count > 0 then
        escape;
    end
    { SPCR &= ~_BV(SPE); }      // disables the SPI Module
end

output (u32 clock, u8 bit_order, u8 data_mode) SPI_TRANSACTION_BEGIN do
    _ceu_assert(not outer.spi_is_busy, "bug found");
    outer.spi_is_busy = true;
    outer.spi_sreg    = {SREG};
    {
        u32 clockSetting = F_CPU / 2;
        u8  clock_div    = 0;
        while (clock_div<6 && @(clock)<clockSetting) {
            clockSetting /= 2;
            clock_div++;
        }

        // Compensate for the duplicate fosc/64
        if (clock_div == 6) {
            clock_div = 7;
        }

        // Invert the SPI2X bit
        clock_div ^= 0x1;

        SPCR = _BV(SPE) | _BV(MSTR) | ((@bit_order == SPI_LSBFIRST) ? _BV(DORD) : 0) |
          (@data_mode & SPI_MODE_MASK) | ((clock_div >> 1) & SPI_CLOCK_MASK);
        SPSR = clock_div & SPI_2XCLOCK_MASK;
    }
end

output none SPI_TRANSACTION_END do
    outer.spi_is_busy = false;
    { SREG = @outer.spi_sreg; }
end

output (u8? value) SPI_TRANSFER_REQUEST do
    {SPCR |= _BV(SPIE);}
    if value? then
        {SPDR = @(value!);}
    else
        {SPDR = SPDR;}  // Have to write something to start conversion
    end
end

input u8 SPI_TRANSFER_DONE;
spawn async/isr [_SPI_STC_vect_num,0] do
    { bitClear(SPCR,SPIE); }
    emit SPI_TRANSFER_DONE({SPDR});
end

code/await SPI_Begin (none) -> none do
    emit SPI_BEGIN;
    do finalize with
        emit SPI_END;
    end
    await FOREVER;
end

event none spi_transaction_end;
var   bool spi_transaction_busy;

code/await SPI_Transaction (var u32 freq, var u8 byte_order, var u8 mode) -> none do
    if outer.spi_transaction_busy then
        await outer.spi_transaction_end until outer.spi_transaction_busy == false;
    end
    outer.spi_transaction_busy = true;

    emit SPI_TRANSACTION_BEGIN(freq,byte_order,mode);
    do finalize with
        emit SPI_TRANSACTION_END;
        outer.spi_transaction_busy = false;
        emit outer.spi_transaction_end;
    end
    await FOREVER;
end

code/await SPI_Transfer (var u8? value) -> u8 do
    emit SPI_TRANSFER_REQUEST(value);
    var u8 recv = await SPI_TRANSFER_DONE;
    escape recv;
end
