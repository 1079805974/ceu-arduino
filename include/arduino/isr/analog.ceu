#include "c.ceu"
#include "arduino/avr.ceu"
#include "arduino/arduino.ceu"

native/pos do
    tceu_callback_ret ceu_callback_analog (int cmd, tceu_callback_arg p1,
                                                    tceu_callback_arg p2,
                                                    const char* file, u32 line)
    {
        tceu_callback_ret ret = { .is_handled=0 };
        switch (cmd) {
            case CEU_CALLBACK_OUTPUT:
                switch (p1.num) {
                    case CEU_OUTPUT_ADC_REQUEST: {
                        ret.is_handled = 1;
                        u8 pin = *((int*)p2.ptr);

                        // if there is a conversion in progress, queue this one
                        if (ADCSRA & _BV(ADSC)) {
                            CEU_APP.root.bit_vector = CEU_APP.root.bit_vector | (0b1 << pin);
                            return;
                        }

                        // set channel (low 3 bits)
                        // this also sets ADLAR (left-adjust result) to 0 (the default).
                        ADMUX = 0x40 | (pin & 0x07);

                        bitSet(ADCSRA, ADIE);    // configures interrupt
                        bitSet(ADCSRA, ADSC);    // starts the conversion
                        break;
                    }
                }
                break;
        }
        return ret;
    }
    tceu_callback CEU_CALLBACK_ANALOG = { &ceu_callback_analog, NULL };
end
{ ceu_callback_register(&CEU_CALLBACK_ANALOG); }

#define N_ADC 6

output int  ADC_REQUEST;
input  none ADC_DONE;

var byte bit_vector = 0;

data ADC_Channel with
    var bool is_available = false;
    var bool is_busy      = false;
    var int  value;
end

var[6] ADC_Channel channels;
do
    var ADC_Channel ch = val ADC_Channel(_,_,_);
    channels = channels .. [ ch, ch, ch, ch, ch, ch ];
end

code/await Analog (var int channel) -> int do
    ceu_assert(outer.channels[channel].is_busy == false, "Simultaneous waits on same pin");

    outer.channels[channel].is_busy = true;
    do finalize with
        outer.channels[channel].is_busy = false;
    end

    emit ADC_REQUEST(channel);
    await ADC_DONE until outer.channels[channel].is_available;
    outer.channels[channel].is_available = false;

    escape outer.channels[channel].value;
end

spawn async/isr [_ADC_vect_num,0] do
    var u8 channel = {ADMUX & 7};

    outer.bit_vector = outer.bit_vector & (({0b00000001} << channel) ^ 0xFF);

    {
        bitClear(ADCSRA, ADSC);
        bitClear(ADCSRA, ADIF);
        bitClear(ADCSRA, ADIE);
    }

    // we have to read ADCL first; doing so locks both ADCL
    // and ADCH until ADCH is read.  reading ADCL second would
    // cause the results of each conversion to be discarded,
    // as ADCL and ADCH would be locked when it completed.
    var byte low  = {ADCL};
    var byte high = {ADCH};

    outer.channels[channel].value = (high << 8) | low;
    outer.channels[channel].is_available = true;
    emit ADC_DONE;

    // gets next conversion in queue
    do
        var byte mask = {0b00000001};
        var int i;
        loop i in [0 -> N_ADC[ do
            if (outer.bit_vector & mask) != 0 then
                emit ADC_REQUEST(i);    // starts new conversion
                escape;                 // prevents interrupt clear below
            end
            mask = mask << 1;
        end
        {bitClear(ADCSRA, ADIE);}       // if none, clears the interrupt bit
    end
end
