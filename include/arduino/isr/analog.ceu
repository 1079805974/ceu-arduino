#include "c.ceu"
#include "arduino/avr.ceu"
#include "arduino/arduino.ceu"

// Event that carries analog value

native/pre do
    ##define CEU_FEATURES_ISR_SLEEP
end

native _analogRead_read,
        _analogRead_begin,
        _dequeue,
        _clear_elem,
        _EMPTY_QUEUE,
        _bit_vector;

native/pos do

    // bit operations, set_bit and clear_bit
    ##ifndef cbi
    ##define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
    ##endif
    ##ifndef sbi
    ##define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
    ##endif

    #define EMPTY_QUEUE 0xff
    #define N_ADC 6

    uint8_t bit_vector = 0;

    void queue(uint8_t e){
        bit_vector = bit_vector | (0b1 << e);
    }

    uint8_t dequeue(void){
        uint8_t mask = 0b1;
        for(int i = 0; i < N_ADC ; i++){
            if(bit_vector & mask){
                return i;
            }
            mask = mask << 1;
        }
        return EMPTY_QUEUE;
    }

    void clear_elem(uint8_t e){
        bit_vector = bit_vector & ((0b1 << e) ^ 0xff );
    }

    //starts a conversion
    void analogRead_begin( uint8_t pin ) {

        // if there is a conversion in progress, queue this one
        if(ADCSRA & _BV(ADSC)){
            queue(pin);
            return;
        }

        // set channel (low 3 bits).  this also sets ADLAR (left-adjust result)
        // to 0 (the default).
        ADMUX = (0x40) | ( pin & 0x07 );

        //configures interrupt
        sbi( ADCSRA, ADIE );

        // start the conversion
        sbi( ADCSRA, ADSC );
    }
    
    int analogRead_read() {

        uint8_t low, high;

        //Serial.println("READ"); Serial.flush();

        cbi(ADCSRA,ADSC);
        cbi(ADCSRA,ADIF);
        cbi(ADCSRA,ADIE);

        // we have to read ADCL first; doing so locks both ADCL
        // and ADCH until ADCH is read.  reading ADCL second would
        // cause the results of each conversion to be discarded,
        // as ADCL and ADCH would be locked when it completed.

        low  = ADCL;
        high = ADCH;

        // combine the two bytes
        return ( high << 8 ) | low;
    }
end

input none ADC_DONE;

var[6] bool available = [false,false,false,false,false,false];
//var bool available = false;
var[6] bool busy = [false,false,false,false,false,false];
 var[6] int sample;
//var int sample = 0;

code/await An (var int channel) -> int do
    atomic do
        _Serial.print("An()->"); _Serial.println(channel); _Serial.flush();
        _Serial.print("An()<-DONE ASSERT "); _Serial.println(channel); _Serial.flush();
    end
    // -->> UNCOMMENTING THIS LINE MAKES CODE BREAK (THIS TRAIL "FREEZES").
    // -->> COMMENTING THIS LINE MAKES CODE BREAK (ASSERT).
    //await 3s;
        var bool is_available = false; 
        if is_available == true then
            var int value;
            atomic do
                _Serial.println("AVAILABLE"); _Serial.flush();
            end
        end
        atomic do
            _Serial.println("WAIT ADC_DONE"); //_Serial.flush();
        // end
        // atomic do
            _Serial.println("DONE WAIT ADC_DONE"); _Serial.flush();
        end
    // Uncommenting this line with 110 commented makes code break (resets)
    // escape(10);
end

spawn async/isr [_ADC_vect_num,0] do
    atomic do
        _Serial.print("INT: "); _Serial.flush();
    end 
    var u8 channel = (_ADMUX & 7);
    atomic do
        _Serial.println(channel);
        _Serial.println(_analogRead_read());
    end
    _clear_elem(channel);
    atomic do
        _Serial.println("EMIT ADC_DONE"); _Serial.flush();
    end
    //atomic do
        // Sets conversion ready
        (outer.available[channel]) = true;
        // Sets value in vector
        var int value = _analogRead_read();

        // --->> IF THIS LINE IS UNCOMMENTED, CODE BREAKS <<--
        //(outer.sample[channel]) = value;
    //end

    // Emits ADC_DONE 
    emit ADC_DONE;
    // gets next conversion in queue
    var u8 next = _dequeue();
    // if none, clear the interrupt bit
    if next != _EMPTY_QUEUE then
        atomic do
            _Serial.print("Next conversion: ");
            _Serial.println(next);
            _analogRead_begin(next);
        end
    else
        _bitClear( _ADCSRA, _ADIE );
    end
    atomic do
        _Serial.println("INT DONE");
    end
end