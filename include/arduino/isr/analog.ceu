#include "arduino/avr.ceu"
#include "arduino/arduino.ceu"

// Event that carries analog value
input int AN;

native/pre do
	##define CEU_FEATURES_ISR_SLEEP
end

native _an_req,
		_analogRead_read;
native/pre do

	// bit operations, set_bit and clear_bit
	##ifndef cbi
	##define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
	##endif
	##ifndef sbi
	##define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
	##endif

	uint8_t analog_reference = DEFAULT;
	
	//starts a conversion
	void analogRead_begin( uint8_t pin ) {

##if defined(analogPinToChannel)
##if defined(__AVR_ATmega32U4__)
	if ( pin >= 18 ) pin -= 18; // allow for channel or pin numbers
##endif
	pin = analogPinToChannel( pin );
##elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
	if ( pin >= 54 ) pin -= 54; // allow for channel or pin numbers
##elif defined(__AVR_ATmega32U4__)
	if ( pin >= 18 ) pin -= 18; // allow for channel or pin numbers
##elif defined(__AVR_ATmega1284__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644__) || defined(__AVR_ATmega644A__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__)
	if ( pin >= 24 ) pin -= 24; // allow for channel or pin numbers
##else
	if ( pin >= 14 ) pin -= 14; // allow for channel or pin numbers
##endif

##if defined(ADCSRB) && defined(MUX5)
	// the MUX5 bit of ADCSRB selects whether we're reading from channels
	// 0 to 7 (MUX5 low) or 8 to 15 (MUX5 high).
	ADCSRB = ( ADCSRB & ~( 1 << MUX5 ) ) | ( ( ( pin >> 3 ) & 0x01 ) << MUX5 );
##endif

	// set the analog reference (high two bits of ADMUX) and select the
	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
	// to 0 (the default).
##if defined(ADMUX)
##if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
	ADMUX = ( analog_reference << 4 ) | ( pin & 0x07 );
##else
	ADMUX = ( analog_reference << 6 ) | ( pin & 0x07 );
##endif
##endif


##if defined(ADCSRA) && defined(ADCL)

	//configures interrupt
	sbi( ADCSRA, ADIE );


	// start the conversion
	sbi( ADCSRA, ADSC );

##endif

}
	int analogRead_read() {

		uint8_t low, high;

		##if defined(ADCSRA) && defined(ADCL)
			// we have to read ADCL first; doing so locks both ADCL
			// and ADCH until ADCH is read.  reading ADCL second would
			// cause the results of each conversion to be discarded,
			// as ADCL and ADCH would be locked when it completed.
		low  = ADCL;
		high = ADCH;
		##else
		// we dont have an ADC, return 0
		low  = 0;
		high = 0;
		##endif

		// combine the two bytes
		return ( high << 8 ) | low;
	}



	void an_req (uint8_t pin){
		analogRead_begin(pin);
	}
end


spawn async/isr [_ADC_vect_num,0] do
	emit AN(_analogRead_read());
end