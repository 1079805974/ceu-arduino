#include "c.ceu"
#include "arduino/avr.ceu"
#include "arduino/arduino.ceu"

#define ADC_N 6

output int  ADC_REQUEST;
input  none ADC_DONE;

var int? adc_channel_busy;      // current working channel
var byte adc_pending = 0;       // bit vectors with requested pending channels

data ADC_Channel with
    var bool is_available = false;
    var bool is_busy      = false;
    var int  value;
end

var[ADC_N] ADC_Channel adc_channels;
do
    var ADC_Channel ch = val ADC_Channel(_,_,_);
    adc_channels = adc_channels .. [ ch, ch, ch, ch, ch, ch ];
end

output (int pin) ADC_REQUEST do
    var int idx = (pin - _A0);
    _ceu_assert(idx>=0 and idx<ADC_N, "pin is out of range");

    if outer.adc_channel_busy? then
        outer.adc_pending = outer.adc_pending | (1 << idx);
        escape;
    end

    outer.adc_channel_busy = idx;

    {
#if ARDUINO_ARCH_AVR
        // sets channel (low 3 bits)
        // this also sets ADLAR (left-adjust result) to 0 (the default).
        ADMUX = 0x40 | (@pin & 0x07);
        bitSet(ADCSRA, ADIE);    // configures interrupt
        bitSet(ADCSRA, ADSC);    // starts the conversion
#elif ARDUINO_ARCH_SAMD

        /* from wiring_analog.c */
        ceu_samd_pinPeripheral(@pin, PIO_ANALOG);

        CEU_SAMD_WAIT(*ADC);
        ADC->INPUTCTRL.bit.MUXPOS = g_APinDescription[@pin].ulADCChannelNumber; // Selection for the positive ADC input

        CEU_SAMD_WAIT(*ADC);
        ADC->CTRLA.bit.ENABLE = 0x01;               // Enable ADC

        CEU_SAMD_WAIT(*ADC);
        ADC->SWTRIG.bit.START = 1;                  // Start conversion
        ADC->INTFLAG.reg = ADC_INTFLAG_RESRDY;      // Clear the Data Ready flag

        CEU_SAMD_WAIT(*ADC);
        NVIC_SetPriority(ADC_IRQn, 0);              //set priority of the interrupt
        NVIC_EnableIRQ(ADC_IRQn);                   // enable ADC interrupts
        ADC->INTENSET.reg |= ADC_INTENSET_RESRDY;   // enable ADC result ready interrupt

        CEU_SAMD_WAIT(*ADC);
        ADC->SWTRIG.bit.START = 1;                  // Start conversion again, since The first conversion after the reference is changed must not be used.

#else
    #error "Unsupported Platform!"
#endif
    }
end

#if ARDUINO_ARCH_AVR
spawn async/isr [_ADC_vect_num,0] do
#elif ARDUINO_ARCH_SAMD
spawn async/isr [_ADC_IRQn,0] do
#else
#error "Unsupported Platform!"
#endif

    var int idx = outer.adc_channel_busy!;
    outer.adc_channel_busy = _;

#if ARDUINO_ARCH_AVR

    {
        bitClear(ADCSRA, ADSC);
        bitClear(ADCSRA, ADIF);
        bitClear(ADCSRA, ADIE);
    }
    // we have to read ADCL first; doing so locks both ADCL
    // and ADCH until ADCH is read.  reading ADCL second would
    // cause the results of each conversion to be discarded,
    // as ADCL and ADCH would be locked when it completed.
    var byte low   = {ADCL};
    var byte high  = {ADCH};
    var u16  value = ((high << 8) | low) as u16;

#elif ARDUINO_ARCH_SAMD

    { ceu_assert(ADC->INTFLAG.bit.RESRDY == 1, "bug found"); }
    var u16 value = {ADC->RESULT.reg};
    {
        CEU_SAMD_WAIT(*ADC);

        ADC->CTRLA.bit.ENABLE = 0x00;             // Disable ADC
        CEU_SAMD_WAIT(*ADC);
    }

#else

    #error "Unsupported Platform!"

#endif

    outer.adc_channels[idx].value = value as int;
    outer.adc_channels[idx].is_available = true;
    emit ADC_DONE;

    // gets next conversion in queue
    outer.adc_pending = outer.adc_pending & ((1 << idx) ^ 0xFF);
    do
        var byte mask = {0b00000001};
        var int i;
        loop i in [0 -> ADC_N[ do
            if (outer.adc_pending & mask) != 0 then
                emit ADC_REQUEST(_A0+i);    // starts new conversion
                escape;                     // prevents interrupt clear below
            end
            mask = mask << 1;
        end
#if ARDUINO_ARCH_AVR
        {bitClear(ADCSRA, ADIE);}       // if none, clears the interrupt bit
#endif
    end
end

code/await Analog (var int pin) -> int do
    var int idx = (pin - _A0);
    _ceu_assert(idx>=0 and idx<ADC_N, "pin is out of range");

    _ceu_assert(not outer.adc_channels[idx].is_busy, "bug found");

    outer.adc_channels[idx].is_busy = true;
    do finalize with
        outer.adc_channels[idx].is_busy = false;
    end

    emit ADC_REQUEST(pin);
    await ADC_DONE until outer.adc_channels[idx].is_available;
    outer.adc_channels[idx].is_available = false;

    escape outer.adc_channels[idx].value;
end
