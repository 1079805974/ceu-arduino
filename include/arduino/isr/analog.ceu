#include "c.ceu"
#include "arduino/avr.ceu"
#include "arduino/arduino.ceu"

#define N_ADC 6

output int  ADC_REQUEST;
input  none ADC_DONE;

var byte bit_vector = 0;

data ADC_Channel with
    var bool is_available = false;
    var bool is_busy      = false;
    var int  value;
end

var[6] ADC_Channel channels;
do
    var ADC_Channel ch = val ADC_Channel(_,_,_);
    channels = channels .. [ ch, ch, ch, ch, ch, ch ];
end

output (int pin) ADC_REQUEST do
    if ({ADCSRA & _BV(ADSC)} as bool) then
        outer.bit_vector = outer.bit_vector | ({0b1} << pin);
        escape;
    end

    {
        // sets channel (low 3 bits)
        // this also sets ADLAR (left-adjust result) to 0 (the default).
        ADMUX = 0x40 | (@pin & 0x07);

        bitSet(ADCSRA, ADIE);    // configures interrupt
        bitSet(ADCSRA, ADSC);    // starts the conversion
    }
end

spawn async/isr [_ADC_vect_num,0] do
    var u8 channel = {ADMUX & 7};

    outer.bit_vector = outer.bit_vector & (({0b00000001} << channel) ^ 0xFF);

    {
        bitClear(ADCSRA, ADSC);
        bitClear(ADCSRA, ADIF);
        bitClear(ADCSRA, ADIE);
    }

    // we have to read ADCL first; doing so locks both ADCL
    // and ADCH until ADCH is read.  reading ADCL second would
    // cause the results of each conversion to be discarded,
    // as ADCL and ADCH would be locked when it completed.
    var byte low  = {ADCL};
    var byte high = {ADCH};

    outer.channels[channel].value = (high << 8) | low;
    outer.channels[channel].is_available = true;
    emit ADC_DONE;

    // gets next conversion in queue
    do
        var byte mask = {0b00000001};
        var int i;
        loop i in [0 -> N_ADC[ do
            if (outer.bit_vector & mask) != 0 then
                emit ADC_REQUEST(i);    // starts new conversion
                escape;                 // prevents interrupt clear below
            end
            mask = mask << 1;
        end
        {bitClear(ADCSRA, ADIE);}       // if none, clears the interrupt bit
    end
end

code/await Analog (var int channel) -> int do
    _ceu_assert(not outer.channels[channel].is_busy, "bug found");

    outer.channels[channel].is_busy = true;
    do finalize with
        outer.channels[channel].is_busy = false;
    end

    emit ADC_REQUEST(channel);
    await ADC_DONE until outer.channels[channel].is_available;
    outer.channels[channel].is_available = false;

    escape outer.channels[channel].value;
end
