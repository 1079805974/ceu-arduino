#include "arduino/avr.ceu"
#include "arduino/arduino.ceu"

#define CEU_TIMER_PRESCALER 1024
#define CEU_TIMER_US_TO_INCS(us)     ((us)*F_CPU/CEU_TIMER_PRESCALER/1000000L)
#define CEU_TIMER_US_TO_OVERFLOW(us) (65536 - CEU_TIMER_US_TO_INCS(us) - 1)
#define CEU_TIMER_INCS_TO_US(incs)   (((s32)(incs))*1000000L*CEU_TIMER_PRESCALER/F_CPU)

native _ceu_arduino_dt;
native/pos do
    static u16 CEU_TIMER_old;
    static int ceu_callback_timer (int cmd, tceu_callback_val p1,
                                   tceu_callback_val p2,
                                   const char* file, u32 line)
    {
        int is_handled = 1;
        switch (cmd) {
            case CEU_CALLBACK_WCLOCK_MIN: {
                s32 us = p1.num;
                if (us == CEU_WCLOCK_INACTIVE) {
                    TIMSK1 = TIMSK1 & ~(1 << TOIE1);
                } else {
                    s32 v = CEU_TIMER_US_TO_OVERFLOW(us);
                    ceu_assert(v > 0, "bug found");
                    TCNT1 = v;
                    CEU_TIMER_old = v;
                    TIMSK1 = TIMSK1 | (1 << TOIE1);
                }
                break;
            }
            default:
                is_handled = 0;
        }
        return is_handled;
    }
    tceu_callback CEU_CALLBACK_TIMER = { &ceu_callback_timer, NULL };

    s32 ceu_arduino_dt (void) {
        u16 now = TCNT1;
        s32 dt  = (now - CEU_TIMER_old);
        CEU_TIMER_old = now;
        return CEU_TIMER_INCS_TO_US(dt);
    }
end

{
    ceu_callback_register(&CEU_CALLBACK_TIMER);

    CEU_TIMER_old = TCNT1;
    TCCR1A = 0;
    TCCR1B = (1 << CS12) | (1 << CS10); // 1024 prescaler
}

spawn async/isr [_TIMER1_OVF_vect_num, 0] do
    emit (_ceu_arduino_dt())us;
end
