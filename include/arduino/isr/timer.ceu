///////////////////////////////////////////////////////////////////////////////
// EXTERNAL INTERFACE
///////////////////////////////////////////////////////////////////////////////

// Language timer (e.g., `await 1s`)

///////////////////////////////////////////////////////////////////////////////
// INTERNAL INTERFACE
///////////////////////////////////////////////////////////////////////////////

#ifndef CEU_TIMER_IRQ_N
    #error missing `CEU_TIMER_IRQ_N`
#endif

#ifndef CEU_TIMER_PRESCALER
    #error missing `CEU_TIMER_PRESCALER`
#endif

native/pre do
    void ceu_timer_init    (void);
    //void ceu_timer         (bool v);      // TODO: ???
    void ceu_timer_request (s32 us);
    void ceu_timer_done    (void);
    s32  ceu_timer_dt      (void);
end

///////////////////////////////////////////////////////////////////////////////
// INITIALIZATION
///////////////////////////////////////////////////////////////////////////////

#define CEU_TIMER_US_TO_INCS(us)     ((s32)(((double)(us))*F_CPU/CEU_TIMER_PRESCALER/1000000L))
#define CEU_TIMER_US_TO_OVERFLOW(us) (65536 - CEU_TIMER_US_TO_INCS(us) - 1) // -1: sleep one more tick to compensate math rounds
#define CEU_TIMER_INCS_TO_US(incs)   ((s32)(((double)(incs))*1000000L*CEU_TIMER_PRESCALER/F_CPU)+1) // +1: add one more us to compensate math round

native/pos do
    static bool ceu_timer_is_active = 0;
    static int ceu_callback_timer (int cmd, tceu_callback_val p1, tceu_callback_val p2)
    {
        switch (cmd) {
            case CEU_CALLBACK_WCLOCK_MIN:
                ceu_timer_request(p1.num);
                ceu_timer_is_active = (p1.num != CEU_WCLOCK_INACTIVE);
##ifdef CEU_FEATURES_ISR_SLEEP
                ceu_pm_set(CEU_PM_TIMER, ceu_timer_is_active);
##endif
                return 1;
            case CEU_CALLBACK_WCLOCK_DT:
                if (ceu_timer_is_active) {
                    ceu_callback_ret.num = ceu_timer_dt();
                } else {
                    ceu_callback_ret.num = CEU_WCLOCK_INACTIVE;
                }
                return 1;
            default:
                return 0;
        }
    }
    static tceu_callback CEU_CALLBACK_TIMER = { &ceu_callback_timer, NULL };
end

{
    ceu_callback_register(&CEU_CALLBACK_TIMER);
    ceu_timer_init();
}

///////////////////////////////////////////////////////////////////////////////
// INPUT / OUTPUT
///////////////////////////////////////////////////////////////////////////////

input none CEU_TIMER;
spawn async/isr [CEU_TIMER_IRQ_N, 0] do
    {ceu_timer_done();}
    emit CEU_TIMER;         // dummy emit to trigger `ceu_input` in env.ino
end
