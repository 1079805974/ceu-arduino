#include "arduino/arduino.ceu"

#define CEU_TIMER_PRESCALER 1024
#define CEU_TIMER_US_TO_INCS(us)     ((us)*F_CPU/CEU_TIMER_PRESCALER/1000000L)
#define CEU_TIMER_US_TO_OVERFLOW(us) (65536 - CEU_TIMER_US_TO_INCS(us) - 1)
#define CEU_TIMER_INCS_TO_US(incs)   (((s32)(incs))*1000000L*CEU_TIMER_PRESCALER/F_CPU)

native/pos do
    void ceu_timer_init (void);
    void ceu_timer_set  (s32 us);
    s32  ceu_timer_dt   (void);

    static int ceu_callback_timer (int cmd, tceu_callback_val p1, tceu_callback_val p2)
    {
        if (cmd == CEU_CALLBACK_WCLOCK_MIN) {
            ceu_timer_set(p1.num);
            return 1;
        } else {
            return 0;
        }
    }
    static tceu_callback CEU_CALLBACK_TIMER = { &ceu_callback_timer, NULL };
end

{
    ceu_callback_register(&CEU_CALLBACK_TIMER);
    ceu_timer_init();
}

#ifdef ARDUINO_ARCH_AVR

#include "arduino/avr.ceu"

native/pos do
    static u16 CEU_TIMER_old;

    void ceu_timer_init (void) {
        CEU_TIMER_old = TCNT1;
        TCCR1A = 0;
        TCCR1B = (1 << CS12) | (1 << CS10); // 1024 prescaler
    }

    void ceu_timer_set (s32 us) {
        if (us == CEU_WCLOCK_INACTIVE) {
            TIMSK1 = TIMSK1 & ~(1 << TOIE1);
        } else {
            s32 v = CEU_TIMER_US_TO_OVERFLOW(us);
            ceu_assert(v > 0, "bug found");
            TCNT1 = v;
            CEU_TIMER_old = v;
            TIMSK1 = TIMSK1 | (1 << TOIE1);
        }
    }

    s32 ceu_timer_dt (void) {
        u16 now = TCNT1;
        s32 dt  = (now - CEU_TIMER_old);
        CEU_TIMER_old = now;
        return CEU_TIMER_INCS_TO_US(dt);
    }
end

spawn async/isr [_TIMER1_OVF_vect_num, 0] do
    emit ({ceu_timer_dt()})us;
end

#elif ARDUINO_ARCH_SAMD

#include "arduino/samd.ceu"

native/pos do
    #define CEU_TIMER_WAIT(x) while (x->STATUS.bit.SYNCBUSY == 1)

    static u16 CEU_TIMER_old;

    void ceu_timer_init (void)
    {
        GCLK->CLKCTRL.reg = (u16) (GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN_GCLK0 | GCLK_CLKCTRL_ID(GCM_TCC2_TC3));
        CEU_TIMER_WAIT(GCLK);

        TcCount16* TC = (TcCount16*) TC3;

        TC->CTRLA.reg &= ~TC_CTRLA_ENABLE;              // disables TC
        CEU_TIMER_WAIT(TC);

        TC->CTRLA.reg |= TC_CTRLA_MODE_COUNT16;         // sets mode to 16 bits
        CEU_TIMER_WAIT(TC);

        TC->CTRLA.reg |= TC_CTRLA_WAVEGEN_NFRQ;         // sets normal freq
        CEU_TIMER_WAIT(TC);

        TC->CTRLA.reg |= TC_CTRLA_PRESCALER_DIV1024;    // sets 1024 prescaler
        CEU_TIMER_WAIT(TC);

        TC->INTENSET.reg = 0;                           // disables all interrupts
        TC->INTENSET.bit.OVF = 1;                       // enables overfollow interrupt
        NVIC_EnableIRQ(TC3_IRQn);                       // enables InterruptVector

        TC->CTRLA.reg |= TC_CTRLA_ENABLE;               // enables the timer
        CEU_TIMER_WAIT(TC);
    }

    void ceu_timer_set (s32 us) {
        if (us == CEU_WCLOCK_INACTIVE) {
            TIMSK1 = TIMSK1 & ~(1 << TOIE1);
        } else {
            s32 v = CEU_TIMER_US_TO_OVERFLOW(us);
            ceu_assert(v > 0, "bug found");
            TCNT1 = v;
            CEU_TIMER_old = v;
            TIMSK1 = TIMSK1 | (1 << TOIE1);
        }
    }

    s32 ceu_timer_dt (void) {
        u16 now = TCNT1;
        s32 dt  = (now - CEU_TIMER_old);
        CEU_TIMER_old = now;
        return CEU_TIMER_INCS_TO_US(dt);
    }
end

spawn async/isr [_TC3_IRQn, 0] do
    emit ({ceu_timer_dt()})us;
end

#else

    #error "Unsupported Platform!"

#endif
