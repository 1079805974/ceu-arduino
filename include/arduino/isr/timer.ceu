#include "arduino/arduino.ceu"

#define CEU_TIMER_PRESCALER 1024
#define CEU_TIMER_US_TO_INCS(us)     ((s32)(((double)(us))*F_CPU/CEU_TIMER_PRESCALER/1000000L))
#define CEU_TIMER_US_TO_OVERFLOW(us) (65536 - CEU_TIMER_US_TO_INCS(us) - 1)
#define CEU_TIMER_INCS_TO_US(incs)   ((s32)(((double)(incs))*1000000L*CEU_TIMER_PRESCALER/F_CPU))

native/pos do
    void ceu_timer_init (void);
    void ceu_timer_set  (s32 us);
    s32  ceu_timer_dt   (void);

    static int ceu_callback_timer (int cmd, tceu_callback_val p1, tceu_callback_val p2)
    {
        if (cmd == CEU_CALLBACK_WCLOCK_MIN) {
            ceu_timer_set(p1.num);
            return 1;
        } else {
            return 0;
        }
    }
    static tceu_callback CEU_CALLBACK_TIMER = { &ceu_callback_timer, NULL };
end

#define S SerialUSB
{ S.begin(9600); }

{
    ceu_callback_register(&CEU_CALLBACK_TIMER);
    ceu_timer_init();
}

#ifdef ARDUINO_ARCH_AVR

#include "arduino/avr.ceu"

native/pos do
    static u16 ceu_timer_old;

    void ceu_timer_init (void) {
        ceu_timer_old = TCNT1;
        TCCR1A = 0;
        TCCR1B = (1 << CS12) | (1 << CS10); // 1024 prescaler
    }

    void ceu_timer_set (s32 us) {
        if (us == CEU_WCLOCK_INACTIVE) {
            TIMSK1 = TIMSK1 & ~(1 << TOIE1);
        } else {
            s32 v = CEU_TIMER_US_TO_OVERFLOW(us);
            ceu_assert(v > 0, "bug found");
            TCNT1 = v;
            ceu_timer_old = v;
            TIMSK1 = TIMSK1 | (1 << TOIE1);
        }
    }

    s32 ceu_timer_dt (void) {
        u16 now = TCNT1;
        s32 dt  = (u16)(now - ceu_timer_old);
        ceu_timer_old = now;
        return CEU_TIMER_INCS_TO_US(dt);
    }
end

spawn async/isr [_TIMER1_OVF_vect_num, 0] do
    emit ({ceu_timer_dt()})us;
end

#elif ARDUINO_ARCH_SAMD

#include "arduino/samd.ceu"

native/pos do
    #define CEU_TIMER_WAIT(x) while (x->STATUS.bit.SYNCBUSY == 1)
    #define CEU_TIMER_TC      ((TcCount16*) TC3)

    static u16 ceu_timer_old;

    void ceu_timer_init (void)
    {
        GCLK->CLKCTRL.reg = (u16) (GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN_GCLK0 | GCLK_CLKCTRL_ID(GCM_TCC2_TC3));
        CEU_TIMER_WAIT(GCLK);

        TcCount16* TC = (TcCount16*) TC3;

        CEU_TIMER_TC->CTRLA.reg &= ~TC_CTRLA_ENABLE;        // disables TC
        CEU_TIMER_WAIT(CEU_TIMER_TC);

        CEU_TIMER_TC->CTRLA.reg |= TC_CTRLA_MODE_COUNT16;   // sets mode to 16 bits
        CEU_TIMER_WAIT(CEU_TIMER_TC);

        CEU_TIMER_TC->CTRLA.reg |= TC_CTRLA_WAVEGEN_NFRQ;   // sets normal freq
        CEU_TIMER_WAIT(CEU_TIMER_TC);

        CEU_TIMER_TC->CTRLA.reg |= TC_CTRLA_PRESCALER_DIV1024; // sets 1024 prescaler
        CEU_TIMER_WAIT(CEU_TIMER_TC);

        CEU_TIMER_TC->INTENSET.reg = 0;                     // disables all interrupts
        CEU_TIMER_TC->INTENSET.bit.OVF = 1;                 // enables overfollow interrupt
        NVIC_EnableIRQ(TC3_IRQn);                           // enables InterruptVector

        ceu_timer_old = REG_TC3_COUNT16_COUNT;
        { S.print("F_CPU "); S.println(F_CPU); }
        { S.print("INIT "); S.println(ceu_timer_old); }

        CEU_TIMER_TC->CTRLA.reg |= TC_CTRLA_ENABLE;         // enables the timer
        CEU_TIMER_WAIT(CEU_TIMER_TC);
    }

    void ceu_timer_set (s32 us) {
        if (us == CEU_WCLOCK_INACTIVE) {
            CEU_TIMER_TC->CTRLBSET.reg |= TC_CTRLBSET_CMD_STOP;      // stops the timer
        } else {
            s32 v = CEU_TIMER_US_TO_OVERFLOW(us);
            ceu_assert(v > 0, "bug found");
            REG_TC3_COUNT16_COUNT = v;
            ceu_timer_old = v;
            { S.print("SET // US "); S.print(us); S.print(" INCS "); S.println(v); }
            CEU_TIMER_TC->CTRLBSET.reg |= TC_CTRLBSET_CMD_RETRIGGER; // starts the timer
        }
    }

    s32 ceu_timer_dt (void) {
        u16 now = REG_TC3_COUNT16_COUNT;
        s32 dt  = (u16)(now - ceu_timer_old);
        ceu_timer_old = now;
        { S.print("NOW "); S.print(now); S.print(" DT "); S.print(dt); S.print(" US "); S.println(CEU_TIMER_INCS_TO_US(dt)); }
        return CEU_TIMER_INCS_TO_US(dt);
    }
end

spawn async/isr [_TC3_IRQn, 0] do
    { CEU_TIMER_TC->INTFLAG.bit.OVF = 1; }                   // clears the ovf flag
    emit ({ceu_timer_dt()})us;
end

#else

    #error "Unsupported Platform!"

#endif
