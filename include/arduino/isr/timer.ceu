#include "arduino/arduino.ceu"

#define CEU_TIMER_PRESCALER 1024
#define CEU_TIMER_US_TO_INCS(us)     ((s32)(((double)(us))*F_CPU/CEU_TIMER_PRESCALER/1000000L))
#define CEU_TIMER_US_TO_OVERFLOW(us) (65536 - CEU_TIMER_US_TO_INCS(us) - 1)
#define CEU_TIMER_INCS_TO_US(incs)   ((s32)(((double)(incs))*1000000L*CEU_TIMER_PRESCALER/F_CPU))

native/pos do
    void ceu_timer_init (void);
    void ceu_timer_set  (s32 us);
    s32  ceu_timer_dt   (void);

    static int ceu_callback_timer (int cmd, tceu_callback_val p1, tceu_callback_val p2)
    {
        if (cmd == CEU_CALLBACK_WCLOCK_MIN) {
            ceu_timer_set(p1.num);
            return 1;
        } else {
            return 0;
        }
    }
    static tceu_callback CEU_CALLBACK_TIMER = { &ceu_callback_timer, NULL };
end

{
    ceu_callback_register(&CEU_CALLBACK_TIMER);
    ceu_timer_init();
}

#if ARDUINO_ARCH_AVR

#include "arduino/avr.ceu"

native/pos do
    static u16 ceu_timer_old;

    void ceu_timer_init (void) {
        ceu_timer_old = TCNT1;
        TCCR1A = 0;
        TCCR1B = (1 << CS12) | (1 << CS10); // 1024 prescaler
    }

    void ceu_timer_set (s32 us) {
        if (us == CEU_WCLOCK_INACTIVE) {
            TIMSK1 = TIMSK1 & ~(1 << TOIE1);
        } else {
            s32 v = CEU_TIMER_US_TO_OVERFLOW(us);
            ceu_assert(v > 0, "bug found");
            TCNT1 = v;
            ceu_timer_old = v;
            TIMSK1 = TIMSK1 | (1 << TOIE1);
        }
    }

    s32 ceu_timer_dt (void) {
        u16 now = TCNT1;
        s32 dt  = (u16)(now - ceu_timer_old);
        ceu_timer_old = now;
        return CEU_TIMER_INCS_TO_US(dt);
    }
end

spawn async/isr [_TIMER1_OVF_vect_num, 0] do
    emit ({ceu_timer_dt()})us;
end

#elif ARDUINO_ARCH_SAMD

#include "arduino/samd.ceu"

native/pos do
    #define CEU_TIMER_TC ((TcCount16*) TC3)

    static u16 ceu_timer_old;

    void ceu_timer_init (void)
    {
        /* Based on <https://forum.arduino.cc/index.php?topic=425385.msg2931200#msg2931200> */

        // Set up the generic clock (GCLK4) used to clock timers
        REG_GCLK_GENDIV = GCLK_GENDIV_DIV(1) |          // Divide the 48MHz clock source by divisor 1: 48MHz/1=48MHz
                          GCLK_GENDIV_ID(4);            // Select Generic Clock (GCLK) 4
        CEU_SAMD_WAIT(*GCLK);

        REG_GCLK_GENCTRL = GCLK_GENCTRL_IDC |           // Set the duty cycle to 50/50 HIGH/LOW
                           GCLK_GENCTRL_GENEN |         // Enable GCLK4
                           GCLK_GENCTRL_SRC_DFLL48M |   // Set the 48MHz clock source
                           GCLK_GENCTRL_ID(4);          // Select GCLK4
        CEU_SAMD_WAIT(*GCLK);

        // Feed GCLK4 to TC4 and TC5
        REG_GCLK_CLKCTRL = GCLK_CLKCTRL_CLKEN |         // Enable GCLK4 to TC4 and TC5
                           GCLK_CLKCTRL_GEN_GCLK4 |     // Select GCLK4
                           GCLK_CLKCTRL_ID_TC4_TC5;     // Feed the GCLK4 to TC4 and TC5
        CEU_SAMD_WAIT(*GCLK);

        NVIC_SetPriority(TC4_IRQn, 0);                  // Set the NVIC priority to highest
        NVIC_EnableIRQ(TC4_IRQn);                       // Connect TC4 to NVIC

        REG_TC4_INTFLAG |= TC_INTFLAG_OVF;              // Clear the interrupt flags
        REG_TC4_INTENSET = TC_INTENSET_OVF;             // Enable TC4 interrupts

        ceu_timer_old = REG_TC4_COUNT16_COUNT;

        REG_TC4_CTRLA |= TC_CTRLA_PRESCALER_DIV1024 |   // Set prescaler to 1024, 48MHz/1024 = 46.875kHz
                         TC_CTRLA_WAVEGEN_NFRQ |        // Put the timer TC4 into match frequency (MFRQ) mode
                         TC_CTRLA_ENABLE;               // Enable TC4
        CEU_SAMD_WAIT(TC4->COUNT16);
    }

    void ceu_timer_set (s32 us) {
        if (us == CEU_WCLOCK_INACTIVE) {
            REG_TC4_CTRLBSET |= TCC_CTRLBSET_CMD_STOP;
        } else {
            s32 v = CEU_TIMER_US_TO_OVERFLOW(us);
            ceu_assert(v > 0, "bug found");
            REG_TC4_COUNT16_COUNT = v;
            ceu_timer_old = v;
            REG_TC4_CTRLBSET |= TCC_CTRLBSET_CMD_RETRIGGER;
        }
    }

    s32 ceu_timer_dt (void) {
        u16 now = REG_TC4_COUNT16_COUNT;
        s32 dt  = (u16)(now - ceu_timer_old);
        ceu_timer_old = now;
        return CEU_TIMER_INCS_TO_US(dt);
    }
end

spawn async/isr [_TC4_IRQn, 0] do
    { REG_TC4_INTFLAG = TC_INTFLAG_OVF; }         // clears the ovf flag
    emit ({ceu_timer_dt()})us;
end

#else

    #error "Unsupported Platform!"

#endif
