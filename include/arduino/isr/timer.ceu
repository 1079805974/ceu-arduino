///////////////////////////////////////////////////////////////////////////////
// EXTERNAL INTERFACE
///////////////////////////////////////////////////////////////////////////////

// Language timer (e.g., `await 1s`)

///////////////////////////////////////////////////////////////////////////////
// INTERNAL INTERFACE
///////////////////////////////////////////////////////////////////////////////

#ifndef CEU_TIMER_IRQ_N
    #error missing `CEU_TIMER_IRQ_N`
#endif

#ifndef CEU_TIMER_PRESCALER
    #error missing `CEU_TIMER_PRESCALER`
#endif

native/pre do
    void ceu_timer_init    (void);
    //void ceu_timer         (bool v);      // TODO: ???
    void ceu_timer_request (s32 us);
    s32  ceu_timer_done    (void);
end

///////////////////////////////////////////////////////////////////////////////
// INITIALIZATION
///////////////////////////////////////////////////////////////////////////////

#define CEU_TIMER_US_TO_INCS(us)     ((s32)(((double)(us))*F_CPU/CEU_TIMER_PRESCALER/1000000L))
#define CEU_TIMER_US_TO_OVERFLOW(us) (65536 - CEU_TIMER_US_TO_INCS(us) - 1)
#define CEU_TIMER_INCS_TO_US(incs)   ((s32)(((double)(incs))*1000000L*CEU_TIMER_PRESCALER/F_CPU))

native/pos do
    static int ceu_callback_timer (int cmd, tceu_callback_val p1, tceu_callback_val p2)
    {
        if (cmd == CEU_CALLBACK_WCLOCK_MIN) {
            ceu_timer_request(p1.num);
            return 1;
        } else {
            return 0;
        }
    }
    static tceu_callback CEU_CALLBACK_TIMER = { &ceu_callback_timer, NULL };
end

{
    ceu_callback_register(&CEU_CALLBACK_TIMER);
    ceu_timer_init();
}

///////////////////////////////////////////////////////////////////////////////
// INPUT / OUTPUT
///////////////////////////////////////////////////////////////////////////////

spawn async/isr [CEU_TIMER_IRQ_N, 0] do
    emit ({ceu_timer_done()})us;
end
